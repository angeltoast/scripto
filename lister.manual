Using the lister functions - Elizabeth Mills
Revised - Elizabeth Mills - 28th April 2021
-------------------------------------------

The scripts described herein are shared in the hope that they will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. A copy of the GNU General Public License is available from the lister page at:

   https://github.com/angeltoast/

   ... or write to:

   The Free Software Foundation, Inc.
   51 Franklin Street, Fifth Floor
   Boston, MA 02110-1301 USA
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Introduction
The philosophy behind lister.sh was conceived as part of the independent Feliz installer for the Arch Linux operating system. At that time, the module was called Listgen', but it has changed completely since those days, and all the functions have been renamed, so a name change seems appropriate. Feliz is no longer maintained, and lister.sh is now an independent project. It is written entirely in bash, so you can edit it to suit your purposes. 

In this guide, aimed at intermediate scripters, we will look at how the functions in the lister.sh module can be incorporated to help you to improve the display of information while running your own scripts.

lister.sh is still in flux at the moment, so it is advised that you check this manual and the lister.quick.ref file before using.

The lister module is self-contained and application-independent. It initialises all its own variables, and contains all the functions it needs; any of the functions may be called independently from any scripts. You only have to put a copy of the lister.sh module in the same location as your scripts, and source it, to be able to add all the features of lister to your scripts.

About The lister.sh functions
This project is designed to help with creating intuitive cli interfaces without using Dialog, Whiptail, or any other external package, especially for situations wher other windowing systems are not available, or where resources are tight. Instead, it uses the tput library to determine the terminal dimensions and to display lists and text centrally according to content.

The functions are named distinctively, so that they stand out in your code:
CallForm        A form for user input;
CallMessage     A message (for information or error-reporting) with an 'Ok' button;
CallMenu:       Generates a menu of one-word items;
CallLongMenu:   Generates a menu of multi-word items;
CallLister:     Prints one or more pages of numbered items, for lists that would exceed
                screen size;
The following functions  in lister.sh are used by the system:
CallHeading:    Prepares a blank window with a heading;
CallFirstItem:  Prints one line of text, centralised on the page;
CallNextItem:   Prints successive items, aligned to the first;
CallButtons:    Prints a button or row of buttons (currently limited to two);
CallPrintRev:   Reverses (ie: highlights) text colour for selected menu item and/or button;
CallActiveMenu: Controls the selection and highlighting of menu items;
CallSelectPage: Selects an appropriate page of data according to user input;
CallPrintPage:  Displays one page of a list, fitting as many columns as possible in
                the window size.
-------------------------------------------------------------
A simple example, using the 'CallMessage' function:
A call to CallMessage passes only one parameter:
$1 The text to be displayed; 

Use it like this:
CallMessage "The file has been updated."
-------------------------------------------------------------
CallMenu
The first and simplest listing function, CallMenu, is for use in shell scripts to generate an interactive menu. It prints the list of options provided, in the form of a scrollable menu, with a pair of 'buttons' to confirm or exit.
Parameters:
$1 String of single-word menu items, or the name of a file containing those items ...
         (max 15 advised, as we don't want to go off the screen, do we?);
$2 Button text, eg: 'Ok Exit' or just 'Ok'...
   These must be single-word options.
   If only one word is passed (eg: 'Ok') then no exit option will be printed.
   In this way you can make sure that your users pick one of the menu items offered;
$3 Optional prompt message, or can be empty.

Example call:
CallMenu "Reboot Shutdown" "Ok Exit"

The first (string array) argument may be passed in one of three ways:
1) It may be specified in the calling line (as above):
	    CallMenu "item1 item2 item3 ... "
2) It may be assigned to a variable:
	    VariableName="item1 item2 item3 ... "
	    For example ...
      	Accessories="Conky Geany Nautilus Terminator"
	      CallMenu "$Accessories"
3) It may be generated by a bash command ...
      	For example â€¦
	        Partitionlist=$(lsblk -l | grep 'part')
	        CallMenu "$Partitionlist" "Ok Done"
      Note: A bash-generated list should be converted to a string array. For example:
	      Zones=(`timedatectl list-timezones | sed 's/\/.*$//' | uniq`)
	      passzones=""
	      for z in ${Zones[@]}; do
	        passzones="$passzones $z"
	      done
	       ...
	      CallMenu "${passzones}" "Select Exit"
CallMenu sets two global variables for use by the calling function ...
1) $GlobalResponse - the item number selected by the user, and
2) $GlobalResult - the label (from the variable array) of the item selected.
This means that you can respond to the user input by using (for example) a 'case - esac' statement or an 'if - else - fi' statement.
----------------------------------------------------------------
CallLongMenu
This is designed for displaying longer descriptions in a menu. It receives the text of the long items via a file. When an item is selected, lister2 finds that item in the file, and saves it as the global variable $Result which may then be used by the calling function if desired. Although complex to set up, it adds greater functionality and user-friendliness for menus. The file must exist, must have each item on its own line in the file, and the file name must be passed as the first parameter, before it can be used.

Parameters:
$1 The name of the file containing the verbose menu items;
$2 Optional button text, eg: 'Ok Exit'
   (if empty will default to 'Ok Exit');
$3 Optional message
   (if $3 is required, $2 must be passed, even if null);
     Notes:
     CallLongMenu requires the named file to exist, or it will abort.
     The named file containing the verbose menu items ...
        1) Should have one item to a line; 
        2) Each line no longer than 50 characters ...
              (we don't want to go off the screen, do we?)

Calling CallLongMenu may take the form:
CallLongMenu "file.name" "Ok Exit" ""
CallLongMenu returns the same global variables as CallMenu.
----------------------------------------------------------------
CallLister
CallLister differs from the other two in that, instead of a cursor-driven menu, it generates a numbered list from which the user can choose by entering the number displayed next to the item. This is provided for situations where a large number of options is to be offered, and a menu would scroll off the screen.
Because CallLister must redraw the screen for each pageful of data to be displayed, it must provide all the text the user needs for advice and prompting. In order to simplify the calling code, CallLister uses a default set of instructions to the user.
The calling function must generate a file containing all the items to be displayed. The items in the file must be only one word each, and must be one to a line.
The file may be generated in any way that produces the list you want to use:
1) It may be passed directly:
    eg: printf "%-s\n" "item1" "item2" "item3" > input.file
2) It may be generated in a loop, eg: 
    for i in names.list
    do
      echo $i >> input.file
    done
3) It may be generated by a bash command ...
      eg: lsblk -l | grep 'part' > input.file

The calling function sends only one parameter:
      $1 The name of the file containing the items.
      So it is, simply: CallLister "file.name"
    
The items are printed on the screen in columns, neatly centred, as many as will comfortably fit the window, with a number next to each item.
At the top of the screen, the message "Page x of x" is displayed. At the bottom, beneath the pageful of data, the user is guided to enter either the number corresponding to the item they wish to select, a 'paging' character ('<' or '>', to go back to a previous page or advance to the next), or to leave the entry box empty if there is nothing they want to select ("or ' ' to exit"). The text advising the user of the paging characters available is intelligently displayed - only valid options are suggested.
Finally, there is a line of prompt text, with the cursor flashing, waiting for user entry. 
CallLister sets the same global output variables as CallMenu and CallLongMenu
